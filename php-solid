#!/usr/bin/env php
<?php

declare(strict_types=1);

use Tivins\Solid\LSP\Config;
use Tivins\Solid\LSP\LiskovSubstitutionPrincipleChecker;
use Tivins\Solid\LSP\ParameterTypeContravarianceRuleChecker;
use Tivins\Solid\LSP\ReturnTypeCovarianceRuleChecker;
use Tivins\Solid\LSP\ThrowsContractRuleChecker;
use Tivins\Solid\LSP\ThrowsDetector;
use Tivins\Solid\LSP\TypeSubtypeChecker;
use Tivins\Solid\Process\ClassFinder;
use Tivins\Solid\Process\FormatType;
use Tivins\Solid\Process\StdWriter;

# Load autoload.php from the root project
$autoload = 'vendor/autoload.php';
if (!is_file($autoload)) {
    throw new Exception('"vendor/autoload.php" not found. Current directory: ' . __DIR__);
}
require $autoload;

// --- CLI options -----------------------------------------------------------

$config = null;
if (in_array('--config', $argv)) {
    $configIndex = array_search('--config', $argv);
    $configFilename = $argv[$configIndex + 1] ?? null;
    if ($configFilename === null || $configFilename === '') {
        fwrite(STDERR, "Error: --config requires a file path.\n");
        exit(2);
    }
    $argv = array_diff_key($argv, array_flip([$configIndex, $configIndex + 1]));
    $argv = array_values($argv);
    try {
        if (!is_file($configFilename) || !is_readable($configFilename)) {
            throw new Exception("Config file '$configFilename' not found or not readable.");
        }
        $config = require $configFilename;
        if (!$config instanceof Config) {
            if (is_object($config)) {
                throw new Exception("Config file '$configFilename' must return a " . Config::class . " object. Got " . get_class($config) . ".");
            } else {
                throw new Exception("Config file '$configFilename' must return a " . Config::class . " object. Got " . gettype($config) . ".");
            }
        }
    } catch (Throwable $e) {
        fwrite(STDERR, "Error: Failed to load config file '$configFilename': " . $e->getMessage() . "\n");
        exit(2);
    }
}

$format = FormatType::TEXT;
if (in_array('--json', $argv)) {
    $format = FormatType::JSON;
}
$verbose = !in_array('--quiet', $argv);

// First non-option argument = directory to scan (used when no --config).
$directory = null;
foreach (array_slice($argv, 1) as $arg) {
    if (!str_starts_with($arg, '--')) {
        $directory = $arg;
        break;
    }
}

if ($config === null) {
    if ($directory === null) {
        fwrite(STDERR, "Usage: php-solid <directory> [--config <file>] [--json] [--quiet]\n");
        fwrite(STDERR, "       php-solid --config <file> [--json] [--quiet]\n");
        fwrite(STDERR, "  <directory>     Path to a directory containing PHP files to check.\n");
        fwrite(STDERR, "  --config <file> Path to a PHP file that returns a " . Config::class . " instance.\n");
        fwrite(STDERR, "  --json          Output violations as JSON.\n");
        fwrite(STDERR, "  --quiet         Minimal output.\n");
        fwrite(STDERR, "\nRun unit tests with: vendor/bin/phpunit\n");
        exit(2);
    }
    if (!is_dir($directory)) {
        fwrite(STDERR, "Error: '$directory' is not a valid directory.\n");
        exit(2);
    }
    $config = (new Config())->addDirectory($directory);
}

# --- Main program -----------------------------------------------------------

$finder  = new ClassFinder();
$classes = $finder->findClassesFromConfig($config);
if (empty($classes)) {
    fwrite(STDERR, "No PHP classes found for the given config.\n");
    exit(0);
}

$writer = new StdWriter($verbose, $format);
$typeChecker = new TypeSubtypeChecker();
$checker = new LiskovSubstitutionPrincipleChecker([
    new ThrowsContractRuleChecker(new ThrowsDetector()),
    new ReturnTypeCovarianceRuleChecker($typeChecker),
    new ParameterTypeContravarianceRuleChecker($typeChecker),
]);
$writer->message("Checking Liskov Substitution Principle...", "\n\n");

$totalViolations = 0;
$failedClasses = 0;
$allViolations = [];
$allErrors = [];

foreach ($classes as $class) {

    $loadError = null;
    try {
        $violations = $checker->check($class);
    } catch (ReflectionException $e) {
        $violations = [];
        $loadError = $e->getMessage();
    }

    $ok = ($loadError === null && count($violations) === 0);
    $writer->content(($ok ? "[PASS]" : "[FAIL]") . " $class", FormatType::TEXT);

    if (!$ok) {
        $failedClasses++;
        if ($loadError !== null) {
            $allErrors[] = ['class' => $class, 'message' => $loadError];
            $writer->content("       -> Error: $loadError", FormatType::TEXT);
        } else {
            $totalViolations += count($violations);
            $allViolations = array_merge($allViolations, $violations);
            foreach ($violations as $violation) {
                $writer->content("       -> $violation", FormatType::TEXT);
            }
        }
    }
}

$writer->message("");
$writer->message("Classes checked: " . count($classes));
$writer->message("Passed: " . (count($classes) - $failedClasses) . " / " . count($classes));
$writer->message("Total violations: $totalViolations");

$violationsAsArray = array_map(
    fn($v) => [
        'className' => $v->className,
        'methodName' => $v->methodName,
        'contractName' => $v->contractName,
        'reason' => $v->reason,
        'details' => $v->details,
    ],
    $allViolations,
);
$jsonReport = [
    'violations' => $violationsAsArray,
    'errors' => $allErrors,
];
$writer->content(json_encode($jsonReport, JSON_PRETTY_PRINT | JSON_UNESCAPED_SLASHES), FormatType::JSON);

// Exit with code 1 if there were any failures, 0 otherwise.
exit($failedClasses > 0 ? 1 : 0);
